class Bike{
	//field variables
	field int x;
	field int y;
	field int originX;
	field int originY;
	field boolean isNotCollided;
	
	//constructor
	constructor Bike new(int xPos, int yPos){
		let x = xPos;
		let y = yPos;
		let originX = xPos;
		let originY = yPos;
		let isNotCollided = true;
		return this;
	}

	//movement Methods (refactor soon)
	method void moveUp(int orientation){
		let y = y-1;							//move & check collision
		do collisionCheck(orientation);
		let y = y-1;
		do collisionCheck(orientation);

		do Screen.setColor(false);				//draw "bike"
		do Screen.drawLine(x, y-6, x-3, y+3);	
		do Screen.drawLine(x-3, y+3, x+3, y+3);
		do Screen.drawLine(x+3, y+3, x, y-6);

		//do Screen.drawPixel(x,y-4);			//leave path (2 pixels to account for movement speed). Needs to be adding path to an array, do it in a separate method.
		//do Screen.drawPixel(x,y-5); 				
		return;
	}

	method void moveRight(int orientation){
		let x = x+1;
		do collisionCheck(orientation);
		let x = x+1;
		do collisionCheck(orientation);

		do Screen.setColor(false);
		do Screen.drawLine(x+6, y, x-3, y-3);
		do Screen.drawLine(x-3, y-3, x-3, y+3);
		do Screen.drawLine(x-3, y+3, x+6, y);
		return;
	}

	method void moveDown(int orientation){
		let y = y+1;
		do collisionCheck(orientation);
		let y = y+1;
		do collisionCheck(orientation);

		do Screen.setColor(false);
		do Screen.drawLine(x, y+6, x-3, y-3);
		do Screen.drawLine(x-3, y-3, x+3, y-3);
		do Screen.drawLine(x+3, y-3, x, y+6);
		return;
	}

	method void moveLeft(int orientation){
		let x = x-1;
		do collisionCheck(orientation);
		let x = x-1;
		do collisionCheck(orientation);

		do Screen.setColor(false);
		do Screen.drawLine(x-6, y, x+3, y-3);
		do Screen.drawLine(x+3, y-3, x+3, y+3);
		do Screen.drawLine(x+3, y+3, x-6, y);
		return;
	}
	
	method void collisionCheck(int orientation){ 	
		var int word;	
		var int bit;	
		var int memAdr; //current word block
		var int memVal;
		var int binPos;
		var int adjX;	
		var int adjY;

		if(isNotCollided){
			if(orientation = 0){
				let word = Memory.peek(16384+((y-7)*32)+(x/16)); //Pixel Above
				let isNotCollided = mod(word,16);
			} 
			if(orientation = 1){
				let word = Memory.peek(16384+(y*32)+((x+7)/16));//+(mod((x+7),16))); //Pixel to Right
				let isNotCollided = mod(word,16);
			} 
			if(orientation = 2){
				let word = Memory.peek(16384+((y+7)*32)+(x/16));//+(mod(x,16))); //Pixel Below
				let isNotCollided = mod(word,16);
			} 
			if(orientation = 3){
				let adjX = x-7;
				let adjY = y;
				let word = adjX/16;

				let bit = adjX-(word*16);
				let memAdr = (16384+((adjY*32) + word));
				let memVal = Memory.peek(memAdr);
				let binPos = power(bit);

				if((~memVal) & binPos){
					let isNotCollided = false;
				}
				else{
					let isNotCollided = true;
				}
				/*
				let word = Memory.peek(16384+(y*32)+((x-7)/16));//+(mod((x-7),16))); //Pixel to Left
				let x2 = (x-7);
				let w = x2/16;
				let isNotCollided = mod(word, (x2-((w-1)*16)));///((x2)-(((x2)/16) / (((x2)/16)-1);
				*/
			} 
			else{}
		}
		return;
	}
	
	method boolean hasItCollided(){
		return isNotCollided;
	}

	method int mod(int dividend, int divisor){
		var int remainder;
		var int quotient;
		var int product;

		let quotient = dividend / divisor;
		let product = divisor * quotient;
		let remainder = dividend - product;

		return remainder;
	}

	method int power(int exp) {

	//method int power(int exp){
		//var int i;
		var int xp;	
		var int n;
		let xp = exp;
		let n = 1;

		//let i = bit;
			if(xp = 0){
				return 1;
			}
			else{
				while(xp >0){
					let n = n+n; //consider +
					let xp = xp -1;
				}
			}
			return n;
		}

	method void resetBike(){
		let x = originX;
		let y = originY;
		let isNotCollided = true;
		return;
	}
	//when you refactor code, consider consolidating 1 move (or maybe "act") method, which receives "orientation," then passes it to three different methods: move, draw, and addPath, which have simple if statements about what to do next, just so you don't have 4, long, similar methods.

	//dispose
}

/// need the local key var, and separate draws