// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/05/CPU.hdl

/**
 * The Hack CPU (Central Processing unit), consisting of an ALU,
 * two registers named A and D, and a program counter named PC.
 * The CPU is designed to fetch and execute instructions written in 
 * the Hack machine language. In particular, functions as follows:
 * Executes the inputted instruction according to the Hack machine 
 * language specification. The D and A in the language specification
 * refer to CPU-resident registers, while M refers to the external
 * memory location addressed by A, i.e. to Memory[A]. The inM input 
 * holds the value of this location. If the current instruction needs 
 * to write a value to M, the value is placed in outM, the address 
 * of the target location is placed in the pc output, and the 
 * writeM control bit is asserted. (When writeM==0, any value may 
 * appear in outM). The outM and writeM outputs are combinational: 
 * they are affected instantaneously by the execution of the current 
 * instruction. The pc and pc outputs are clocked: although they 
 * are affected by the execution of the current instruction, they commit 
 * to their new values only in the next time step. If reset==1 then the 
 * CPU jumps to address 0 (i.e. pc is set to 0 in next time step) rather 
 * than to the address resulting from executing the current instruction. 
 */

CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])	  The value recieved
        instruction[16], // Instruction for execution				  A or C instruction
        reset;           // Signals whether to re-start the current	  Reset or not
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value outputs 						  data
        writeM,          // Write to M? 							  load
        addressM[15],    // Address in data memory (of M)			  mem adr
        pc[15];          // address of next Instruction 			  ROM adr for next

    PARTS:
    // Put your code here:
    Mux16(a = instruction, b = ALUResult, sel = instruction[15], out = outToARegister);
    ARegister(in = outToARegister, load = instruction[5], out = ARegisterResult); //A REGISTER
    Mux16(a = ARegisterResult, b = inM, sel = instruction[12], out = AOrMResult);
    DRegister(in = ALUResult, load = instruction[4], out = DRegisterResult); //D REGISTER
    ALU(x = ARegisterResult, y = DRegisterResult, zx = instruction[11], nx = instruction[10], zy = instruction[9], ny = instruction[8], f = instruction[7], no = instruction[6], out = ALUResult, zr = ALUz, ng = ALUn);
    And16(a = ALUResult, b = ALUResult, out = outM); //Just had to get ALUResult to outM

    //NOTE for future me: Address M & Write M are outputting incorrectly. I *think* they're not supposed to do anything until program counter ticks once. Uncertain. Maybe try it with both CPU test files, to see if they react differently (I doubt they will, but worth a shot.) - no, I don't think this is correct.

    //only if instruction15 (aorc) = 0\1, && instruction3 = 1, writeM.
    And(a = instruction[3], b = instruction[15], out = writeM); 

    //There has to be a better way than this mess. // Also should not trigger on A commands. Only C.
    //Also, the number it outputs, in addition to the initial bit it is supposed to excise, is also missing a bit from either end.
    And16(a = ARegisterResult, b = ARegisterResult, out[0] = false, out[1] = addressM[0],out[2] = addressM[1],out[3] = addressM[2],out[4] = addressM[3],out[5] = addressM[4],out[6] = addressM[5],out[7] = addressM[6],out[8] = addressM[7],out[9] = addressM[8],out[10] = addressM[9],out[11] = addressM[10],out[12] = addressM[11],out[13] = addressM[12],out[14] = addressM[13],out[15] = addressM[14]);
    //And(a = instruction[1], b = instruction[1], out = addressM[0]);
    //And(a = instruction[2], b = instruction[2], out = addressM[1]);
    //And(a = instruction[3], b = instruction[3], out = addressM[2]);
    //And(a = instruction[4], b = instruction[4], out = addressM[3]);
    //And(a = instruction[5], b = instruction[5], out = addressM[4]);
    //And(a = instruction[6], b = instruction[6], out = addressM[5]);
    //And(a = instruction[7], b = instruction[7], out = addressM[6]);
    //And(a = instruction[8], b = instruction[8], out = addressM[7]);
    //And(a = instruction[9], b = instruction[9], out = addressM[8]);
    //And(a = instruction[10], b = instruction[10], out = addressM[9]);
    //And(a = instruction[11], b = instruction[11], out = addressM[10]);
    //And(a = instruction[12], b = instruction[12], out = addressM[11]);
    //And(a = instruction[13], b = instruction[13], out = addressM[12]);
    //And(a = instruction[14], b = instruction[14], out = addressM[13]);
    //And(a = instruction[15], b = instruction[15], out = addressM[14]);

    Not(in = ALUz, out = NotALUz);
    Not(in = ALUn, out = NotALUn);
    And(a = NotALUn, b = NotALUz, out = JGTb);
    Or(a = ALUn, b = ALUz, out = JLEg);

    Mux(a = false, b = ALUz, sel = instruction[1], out = outac);
    Mux(a = JGTb, b = NotALUn, sel = instruction[1], out = outbd);
    Mux(a = outac, b = outbd, sel = instruction[2], out = abcd);
    Mux(a = ALUn, b = JLEg, sel = instruction[1], out = outeg);
    Mux(a = NotALUz, b = true, sel = instruction[1], out = outfh);
    Mux(a = outeg, b = outfh, sel = instruction[2], out = efgh);
    Mux(a = abcd, b = efgh, sel = instruction[0], out = jumpResult);

    Not(in = jumpResult, out = incResult);

    PC(in = ARegisterResult, load = jumpResult, inc = incResult, reset = reset, out[15] = false, out[0..14] = pc);
}